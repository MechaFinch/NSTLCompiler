package notsotiny.lang.compiler.codegen;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;

import notsotiny.lang.compiler.aasm.AASMLabel;
import notsotiny.lang.compiler.aasm.AASMLiveSet;
import notsotiny.lang.compiler.aasm.AASMPart;
import notsotiny.lang.ir.parts.IRBasicBlock;
import notsotiny.lang.ir.parts.IRBranchInstruction;
import notsotiny.lang.ir.parts.IRBranchOperation;
import notsotiny.lang.ir.parts.IRFunction;
import notsotiny.lang.ir.parts.IRIdentifier;
import notsotiny.lang.util.Pair;

/**
 * Schedules basic blocks
 */
public class InterBlockScheduler {
    
    private static Logger LOG = Logger.getLogger(InterBlockScheduler.class.getName());
    
    /**
     * Schedules the basic blocks
     * @param function
     * @param bbAASMs
     * @param livenessSets
     * @return
     */
    public static List<List<AASMPart>> scheduleBlocks(IRFunction function, Map<IRIdentifier, List<List<AASMPart>>> bbAASMs, Map<IRIdentifier, Pair<Set<IRIdentifier>, Set<IRIdentifier>>> livenessSets) {
        
        LOG.finer("Scheduling blocks in " + function.getID());
        
        List<List<AASMPart>> parts = new ArrayList<>();
        
        // Modify liveness sets to reflect non-SSA form and current code generation for function arguments
        // Code at this point is not in SSA form. Therefore, arguments of a BB should be live-out in blocks
        // that branch to the BB.
        // Function arguments are loaded on demand for a given BB, therefore remove them from liveness sets
        List<IRIdentifier> argNames = function.getArguments().getNameList();
        
        for(Entry<IRIdentifier, Pair<Set<IRIdentifier>, Set<IRIdentifier>>> entry : livenessSets.entrySet()) {
            IRIdentifier bbID = entry.getKey();
            Set<IRIdentifier> liveIn = entry.getValue().a;
            Set<IRIdentifier> liveOut = entry.getValue().b;
            
            // Remove function arguments from liveness sets
            liveIn.removeAll(argNames);
            liveOut.removeAll(argNames);
            
            // Add target args to live out
            // The conditional argument pretransformer ensures only unconditional branches have arg assignments
            IRBranchInstruction exit = function.getBasicBlock(bbID).getExitInstruction();
            
            if(exit.getOp() == IRBranchOperation.JMP) {
                liveOut.addAll(exit.getTrueArgumentMapping().getMap().keySet());
            }
        }
        
        // Schedule
        schedule(parts, function.getBasicBlockList().get(0).getID(), function, bbAASMs, livenessSets, new HashSet<>());
        
        // Report scheduled code
        if(LOG.isLoggable(Level.FINEST)) {
            for(List<AASMPart> group : parts) {
                for(AASMPart part : group) {
                    if(part instanceof AASMLabel) {
                        LOG.finest(part + "");
                    } else {
                        LOG.finest("\t" + part);
                    }
                }
            }
        }
        
        return parts;
    }
    
    /**
     * Adds a basic block to the code and schedules its successors recursively
     * @param parts
     * @param blockID
     * @param function
     * @param bbAASMs
     * @param livenessSets
     * @param scheduledBlocks
     */
    private static void schedule(List<List<AASMPart>> parts, IRIdentifier blockID, IRFunction function, Map<IRIdentifier, List<List<AASMPart>>> bbAASMs, Map<IRIdentifier, Pair<Set<IRIdentifier>, Set<IRIdentifier>>> livenessSets, Set<IRIdentifier> scheduledBlocks) {
        if(scheduledBlocks.contains(blockID)) {
            // Already scheduled
            return;
        }
        
        scheduledBlocks.add(blockID);
        
        // Retrieve basic block info
        IRBasicBlock block = function.getBasicBlock(blockID);
        Pair<Set<IRIdentifier>, Set<IRIdentifier>> liveness = livenessSets.get(blockID);
        Set<IRIdentifier> liveInSet = liveness.a;
        Set<IRIdentifier> liveOutSet = liveness.b;
        
        // Label the block and add live-in information
        parts.add(List.of(new AASMLabel(blockID + ""), new AASMLiveSet(liveInSet, new HashSet<>(), true)));
        
        // Add the basic block's code
        for(List<AASMPart> group : bbAASMs.get(blockID)) {
            if(!group.isEmpty()) {
                parts.add(group);
            }
        }
        
        // Add live-out information
        parts.add(List.of(new AASMLiveSet(liveOutSet, new HashSet<>(), false)));
        
        // Schedule successors
        IRBranchInstruction exit = block.getExitInstruction();
        
        switch(exit.getOp()) {
            case JCC:
                // Two successors
                // The trailing branch of a conditional branch generated by the pattern matcher is to the false target
                // Schedule false target first to eliminate the trailing jump if it hasn't already been scheduled
                schedule(parts, exit.getFalseTargetBlock(), function, bbAASMs, livenessSets, scheduledBlocks);
                schedule(parts, exit.getTrueTargetBlock(), function, bbAASMs, livenessSets, scheduledBlocks);
                break;
                
            case JMP:
                // One successor
                schedule(parts, exit.getTrueTargetBlock(), function, bbAASMs, livenessSets, scheduledBlocks);
                break;
                
            case RET:
                // No successors
                break;
                
            default:
                throw new IllegalArgumentException("Unexpected exit op: " + exit);
        }
    }
    
}
