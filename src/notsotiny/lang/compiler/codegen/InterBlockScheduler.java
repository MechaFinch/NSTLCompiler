package notsotiny.lang.compiler.codegen;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;

import notsotiny.lang.compiler.aasm.AASMLabel;
import notsotiny.lang.compiler.aasm.AASMLiveSet;
import notsotiny.lang.compiler.aasm.AASMPart;
import notsotiny.lang.ir.parts.IRBasicBlock;
import notsotiny.lang.ir.parts.IRBranchInstruction;
import notsotiny.lang.ir.parts.IRFunction;
import notsotiny.lang.ir.parts.IRIdentifier;
import notsotiny.lang.util.Pair;

/**
 * Schedules basic blocks
 */
public class InterBlockScheduler {
    
    private static Logger LOG = Logger.getLogger(InterBlockScheduler.class.getName());
    
    /**
     * Schedules the basic blocks
     * @param function
     * @param bbAASMs
     * @param livenessSets
     * @return
     */
    public static List<AASMPart> scheduleBlocks(IRFunction function, Map<IRIdentifier, List<AASMPart>> bbAASMs, Map<IRIdentifier, Pair<Set<IRIdentifier>, Set<IRIdentifier>>> livenessSets) {
        
        LOG.finer("Scheduling blocks in " + function.getID());
        
        List<AASMPart> parts = new ArrayList<>();
        
        // Remove function arguments from liveness sets
        // Function arguments are loaded from the stack on demand with current code generation
        List<IRIdentifier> argNames = function.getArguments().getNameList();
        
        for(Pair<Set<IRIdentifier>, Set<IRIdentifier>> liveness : livenessSets.values()) {
            liveness.a.removeAll(argNames);
            liveness.b.removeAll(argNames);
        }
        
        // Schedule
        schedule(parts, function.getBasicBlockList().get(0).getID(), function, bbAASMs, livenessSets, new HashSet<>());
        
        // Report scheduled code
        if(LOG.isLoggable(Level.FINEST)) {
            for(AASMPart part : parts) {
                if(part instanceof AASMLabel) {
                    LOG.finest(part + "");
                } else {
                    LOG.finest("\t" + part + "");
                }
            }
        }
        
        return parts;
    }
    
    /**
     * Adds a basic block to the code and schedules its successors recursively
     * @param parts
     * @param blockID
     * @param function
     * @param bbAASMs
     * @param livenessSets
     * @param scheduledBlocks
     */
    private static void schedule(List<AASMPart> parts, IRIdentifier blockID, IRFunction function, Map<IRIdentifier, List<AASMPart>> bbAASMs, Map<IRIdentifier, Pair<Set<IRIdentifier>, Set<IRIdentifier>>> livenessSets, Set<IRIdentifier> scheduledBlocks) {
        if(scheduledBlocks.contains(blockID)) {
            // Already scheduled
            return;
        }
        
        scheduledBlocks.add(blockID);
        
        // Retrieve basic block info
        IRBasicBlock block = function.getBasicBlock(blockID);
        Pair<Set<IRIdentifier>, Set<IRIdentifier>> liveness = livenessSets.get(blockID);
        Set<IRIdentifier> liveInSet = liveness.a;
        Set<IRIdentifier> liveOutSet = liveness.b;
        
        // Label the block
        parts.add(new AASMLabel(blockID + ""));
        
        // Add live-in information
        parts.add(new AASMLiveSet(liveInSet));
        
        // Add the basic block's code
        parts.addAll(bbAASMs.get(blockID));
        
        // Add live-out information
        parts.add(new AASMLiveSet(liveOutSet));
        
        // Schedule successors
        IRBranchInstruction exit = block.getExitInstruction();
        
        switch(exit.getOp()) {
            case JCC:
                // Two successors
                // The trailing branch of a conditional branch generated by the pattern matcher is to the false target
                // Schedule false target first to eliminate the trailing jump if it hasn't already been scheduled
                schedule(parts, exit.getFalseTargetBlock(), function, bbAASMs, livenessSets, scheduledBlocks);
                schedule(parts, exit.getTrueTargetBlock(), function, bbAASMs, livenessSets, scheduledBlocks);
                break;
                
            case JMP:
                // One successor
                schedule(parts, exit.getTrueTargetBlock(), function, bbAASMs, livenessSets, scheduledBlocks);
                break;
                
            case RET:
                // No successors
                break;
                
            default:
                throw new IllegalArgumentException("Unexpected exit op: " + exit);
        }
    }
    
}
