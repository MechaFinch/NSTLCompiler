/*
 * WARNING: this file has been generated by
 * Hime Parser Generator 4.2.1
 */

package notsotiny.lang.compiler.codegen.pattern;

import fr.cenotelie.hime.redist.ASTNode;
import fr.cenotelie.hime.redist.ParseResult;
import fr.cenotelie.hime.redist.SemanticAction;
import fr.cenotelie.hime.redist.SemanticBody;
import fr.cenotelie.hime.redist.Symbol;
import fr.cenotelie.hime.redist.parsers.InitializationException;
import fr.cenotelie.hime.redist.parsers.LRkAutomaton;
import fr.cenotelie.hime.redist.parsers.LRkParser;

import java.util.Map;

/**
 * Represents a parser
 */
public class IselPatternParser extends LRkParser {
    /**
     * The automaton for this parser
     */
    private static final LRkAutomaton COMMON_AUTOMATON = LRkAutomaton.find(IselPatternParser.class, "IselPatternParser.bin");
    /**
     * Contains the constant IDs for the variables and virtuals in this parser
     */
    public static class ID {
        /**
         * The unique identifier for variable patlist
         */
        public static final int VARIABLE_PATLIST = 0x000D;
        /**
         * The unique identifier for variable pattern
         */
        public static final int VARIABLE_PATTERN = 0x000E;
        /**
         * The unique identifier for variable conversion
         */
        public static final int VARIABLE_CONVERSION = 0x000F;
        /**
         * The unique identifier for variable expression
         */
        public static final int VARIABLE_EXPRESSION = 0x0010;
        /**
         * The unique identifier for variable expr_node
         */
        public static final int VARIABLE_EXPR_NODE = 0x0011;
        /**
         * The unique identifier for variable expr_pat
         */
        public static final int VARIABLE_EXPR_PAT = 0x0012;
        /**
         * The unique identifier for variable expr_ref
         */
        public static final int VARIABLE_EXPR_REF = 0x0013;
        /**
         * The unique identifier for variable assembly
         */
        public static final int VARIABLE_ASSEMBLY = 0x0014;
        /**
         * The unique identifier for variable instruction
         */
        public static final int VARIABLE_INSTRUCTION = 0x0015;
        /**
         * The unique identifier for variable memory
         */
        public static final int VARIABLE_MEMORY = 0x0016;
        /**
         * The unique identifier for variable index
         */
        public static final int VARIABLE_INDEX = 0x0017;
        /**
         * The unique identifier for variable iarg
         */
        public static final int VARIABLE_IARG = 0x0018;
        /**
         * The unique identifier for variable arg
         */
        public static final int VARIABLE_ARG = 0x0019;
    }
    /**
     * The collection of variables matched by this parser
     *
     * The variables are in an order consistent with the automaton,
     * so that variable indices in the automaton can be used to retrieve the variables in this table
     */
    private static final Symbol[] variables = {
        new Symbol(0x000D, "patlist"), 
        new Symbol(0x000E, "pattern"), 
        new Symbol(0x000F, "conversion"), 
        new Symbol(0x0010, "expression"), 
        new Symbol(0x0011, "expr_node"), 
        new Symbol(0x0012, "expr_pat"), 
        new Symbol(0x0013, "expr_ref"), 
        new Symbol(0x0014, "assembly"), 
        new Symbol(0x0015, "instruction"), 
        new Symbol(0x0016, "memory"), 
        new Symbol(0x0017, "index"), 
        new Symbol(0x0018, "iarg"), 
        new Symbol(0x0019, "arg"), 
        new Symbol(0x001A, "__V26"), 
        new Symbol(0x001D, "__V29"), 
        new Symbol(0x001E, "__V30"), 
        new Symbol(0x0022, "__V34"), 
        new Symbol(0x0023, "__V35"), 
        new Symbol(0x0026, "__V38"), 
        new Symbol(0x002C, "__V44"), 
        new Symbol(0x002D, "__VAxiom") };
    /**
     * The collection of virtuals matched by this parser
     *
     * The virtuals are in an order consistent with the automaton,
     * so that virtual indices in the automaton can be used to retrieve the virtuals in this table
     */
    private static final Symbol[] virtuals = {
 };
    /**
     * Initializes a new instance of the parser
     *
     * @param lexer The input lexer
     */
    public IselPatternParser(IselPatternLexer lexer) {
        super(COMMON_AUTOMATON, variables, virtuals, null, lexer);
    }

    /*
     * Visitor interface
     */
    public static class Visitor {
        public void onTerminalSeparator(ASTNode node) {}
        public void onTerminalIdentifier(ASTNode node) {}
        public void onTerminalName(ASTNode node) {}
        public void onTerminalNumber(ASTNode node) {}
        public void onTerminalType(ASTNode node) {}
        public void onVariablePatlist(ASTNode node) {}
        public void onVariablePattern(ASTNode node) {}
        public void onVariableConversion(ASTNode node) {}
        public void onVariableExpression(ASTNode node) {}
        public void onVariableExprNode(ASTNode node) {}
        public void onVariableExprPat(ASTNode node) {}
        public void onVariableExprRef(ASTNode node) {}
        public void onVariableAssembly(ASTNode node) {}
        public void onVariableInstruction(ASTNode node) {}
        public void onVariableMemory(ASTNode node) {}
        public void onVariableIndex(ASTNode node) {}
        public void onVariableIarg(ASTNode node) {}
        public void onVariableArg(ASTNode node) {}
    }

    /*
     * Walk the AST of a result using a visitor
     *
     * @param result  The parse result
     * @param visitor The visitor to use
     */
    public static void visit(ParseResult result, Visitor visitor) {
        visitASTNode(result.getRoot(), visitor);
    }

    /*
     * Walk the sub-AST from the specified node using a visitor
     *
     * @param node    The AST node to start from
     * @param visitor The visitor to use
     */
    public static void visitASTNode(ASTNode node, Visitor visitor) {
        for (ASTNode child : node.getChildren())
            visitASTNode(child, visitor);
        switch(node.getSymbol().getID()) {
            case 0x0006: visitor.onTerminalSeparator(node); break;
            case 0x0009: visitor.onTerminalIdentifier(node); break;
            case 0x000A: visitor.onTerminalName(node); break;
            case 0x000B: visitor.onTerminalNumber(node); break;
            case 0x000C: visitor.onTerminalType(node); break;
            case 0x000D: visitor.onVariablePatlist(node); break;
            case 0x000E: visitor.onVariablePattern(node); break;
            case 0x000F: visitor.onVariableConversion(node); break;
            case 0x0010: visitor.onVariableExpression(node); break;
            case 0x0011: visitor.onVariableExprNode(node); break;
            case 0x0012: visitor.onVariableExprPat(node); break;
            case 0x0013: visitor.onVariableExprRef(node); break;
            case 0x0014: visitor.onVariableAssembly(node); break;
            case 0x0015: visitor.onVariableInstruction(node); break;
            case 0x0016: visitor.onVariableMemory(node); break;
            case 0x0017: visitor.onVariableIndex(node); break;
            case 0x0018: visitor.onVariableIarg(node); break;
            case 0x0019: visitor.onVariableArg(node); break;
        }
    }
}
